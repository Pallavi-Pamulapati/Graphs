





   BOOK 

  ON GRAPH 

  ALGORITHMS	


Algorithms Analysis & Design Project





Chapter 1: Introduction

Graph Data Structure: 
	A non linear data structure that consists of nodes (vertices) and edges. Edges are lines that connect a node to another node or to itself in a graph. Formally, Graph contains a finite set of nodes (vertices) and a set of edges which connect a pair of nodes.

In this book we assume that the vertices of the graph are indexed from 1. 
Chapter 2: Search and Sort
Searching a Graph
Two Algorithms that are widely used to search in a graph are Depth-First Search (DFS) and Breadth-First Search (BFS)

Depth-First Search: 
DFS is an algorithm for searching or traversing a graph both directed or undirected.
	As the name suggests it searches as deeper as possible in the graph. 
IDEA: 
	Visits all the nodes that are not visited from recently visited node and if all the vertices that are reachable from the vertex are seen then it recurses back. Here, when we reach a node it is marked as seen, and is marked as visited when all the nodes that are reachable from the node are seen.
	Here we maintain  the information about whether the node is seen or not because the graph may contain cycles. If the cycle is present in a graph then we may visit the node twice and keep on moving in the loop if we don't maintain the information whether the node is visited or not.
Let us see an example to see the working of the algorithm. 
Example: 
	Consider a directed graph G shown below 
	      Here initially all the nodes are marked as not visited.Now lets start the algorithm from node 1. 
Now, we mark the node 1 as seen and move to the next node that can be reached (node 2).
 
Now, we mark the node 2 as seen and move to the next node that can be reached from 2 and as there are two nodes 3 and 5 we choose the left node.

Now as there are no nodes that can be reached from 5 we mark the node 5 as visited and recurse back to 2. And we move to node 3 that can be reached from 2.

Now as all the nodes that are reachable from 3 are seen we mark node 3 as visited and recurse back to node 2.
 
As all the nodes that can be reached from node 2 are seen we recurse back to node 1. 

As all the nodes that are reachable from node 1 are seen we mark 1 as visited. And as we cannot recurse back from 1 we check whether all nodes in the graph are visited and select the node that is not visited. So, now we select the node 4.

Now, we mark 4 as seen and move to node 6 (node that is reachable from 4).

Now as there are no nodes that can be reached from 6 we mark 6 as visited and recurse back to 4.

As all the nodes that are reachable from 4 are seen we mark 4 as visited. As there are no nodes to recurse back and all the nodes of the graph are seen the final output of the traversal is 
	1,2,5,3,4,6.
There can be multiple traversals and the Algorithm gives one the traversal. The other traversals for the above graph can be (4,1,2,5,3,6); (6,4,1,2,5,3); … 
 
Algorithm: 
We maintain an array to know the status of the node (not-visited, seen or visited). Then mark every vertex of the graph as not-visited.
And every non visited vertex in the graph is passed as an argument to the function DFS_Traversal()
In the function DFS_Traversal() we mark the non-visited node as seen and then we move to the vertices that can be reached from the node. And do the same.
After performing this on all the vertices that can be reached we mark the root vertex as visited.

Pseudo Code:
DFS(Graph G,int V)
{
   // status[i] = 0 => not visited, 1 => seen, 2 => visited
   int status[V+1] = {0}; // V = no.of Vertices
   for every vertex v ∈ V  // V = set of vertices of G
       if(status[v] == 0)
           DFS_Traversal(G, v, status);
   return;
}
DFS_Traversal(Graph G, int v, int* status)
{
   status[v] = 1;
   for every u ∈ Adj[v] // => there is a vertex from v to u
       if(status[u] == 0)
           DFS_Traversal(G,u,status);
   status[v] = 2;
   return;
}

Code Implementation:
 	# check vscode.
Analysis
Time Complexity:
	According to the algorithm DFS_Traversal() is called for each vertex exactly once and in the function we check all the edges from the vertex. So, we are checking all the edges of the graph. 
	Thus, Time complexity of the Algorithm is O(V+E) where V = number of vertices of the graph and E = number of the edges of the graph
Space Complexity: 
As we are maintaining an additional array of size V+1 to store the information about whether the node is visited or not. The Space Complexity of the algorithm is O(V).
Applications:
Helps to find Strongly connected components in a graph.
Detect a cycle in a graph 
To check if the graph is bipartite
Find a path between two given vertices.

Breadth-First Search: 
	BFS is also an algorithm to search in or traverse a graph. As the name suggests it visits all the nodes that are present at the same level first and then advances to the next level.This continues till all the nodes of the graph or visited or stops when we find the required node.
	This can be used in both directed and undirected graphs.
Algorithm: 
We maintain a status array to find out whether the node is not-visited, seen or visited. And we also maintain a queue
Now we choose a node (start node) and then push it’s neighbours on to the queue and then pop an element from the queue and push it’s neighbours on to the queue and so on.. 
We do this till all the nodes are reached from the point and then we choose another node from the graph that is not visited and repeat the same process till all the nodes in the graph are visited. 
The status of the node that is not visited is set as 0 and the status of the node that is in the queue is set as 1 and the node that is popped from the queue is set as 2.
The order of popping the elements is the required BFS traversal.
Let us see an example to see the working of the algorithm.
Example: 
Consider an undirected graph G shown below

Initially the status array is initialized to 0. Now we start with 1 and push it on to the queue and update its status.

Now we pop 1 from the queue and push its neighbours 2 3 5 onto the queue and update the status of nodes 1, 2, 3 and 5 to 2, 1, 1 and 1 respectively.

Now we pop 2 from the queue and push its neighbours onto the queue and update their status.

As there are no neighbours for 3 we just pop 3 from the queue and update the status.
 
Now we pop 5 from the queue and push 6 onto the queue and update their status. 

As there are no neighbours for 4 we just pop 4 from the queue and update the status.

As there are no neighbours for 6 we just pop 6 from the queue and update the status.

Now, All the nodes of the graph are visited.The BFS traversal is 1 2 3 5 4 6.
Pseudo Code:
BFS(Graph G, int V)
{
   vector<int> status(V+1, 0);     // status array
   queue<int> que;         // queue
   for every vertex s ∈ V  // V = set of vertices of G
       if(status[s] == 0)
           que.push(s);
           status[s] = 1;
           BFS_Traversal(G, status, que);
   return;
}
BFS_Traversal(Graph G, vector<int> &status, queue<int> &que)
{
   while queue is not empty
       int v = que.front();
       que.pop();
       // pushing the neighbours of v into queue
       for every u ∈ Adj[v]      // => there is a vertex from v to u
           if(status[u] == 0)
               que.push(u);
               status[u] = 1;      // u is seen
       status[v] = 2;          // v is visited 
   return;
}
Code Implementation:
	// vscode
Analysis:
Time Complexity: 
	Each vertex of the graph is pushed and popped from the queue exactly once.The operations pushing and popping from the queue are constant time operations.So, the time taken to do this is O(V). 
	For each vertex we are checking all the neighbours. So, in total we are checking all the edges in the graph and the time taken to do this is O(E). 
	Thus, Overall time taken by the algorithm is O(V+E) where V = no.of vertices and E = no.of edges of the graph.
Space Complexity: 
	As we are maintaining an array and queue which in the worst case may contain V-1 elements. The space complexity of BFS is O(V).
Applications: 
Cycle detection in undirected graphs
To test if a graph is bipartite
Find path between two vertices 
GPS navigation systems to find all neighbouring places.
Shortest path in undirected graph.

// shortest path 	-- Dijkstra, bellman ford, Flloyd warshal
