





   BOOK 

  ON GRAPH 

  ALGORITHMS	


Algorithms Analysis & Design Project





Chapter 1: Introduction

Graph Data Structure: 
	A non linear data structure that consists of nodes (vertices) and edges. Edges are lines that connect a node to another node or to itself in a graph. Formally, Graph contains a finite set of nodes (vertices) and a set of edges which connect a pair of nodes.

In this book we assume that the vertices of the graph are indexed from 1. 
Chapter 2: Search and Sort
Searching or Traversing a Graph
Two Algorithms that are widely used to search in a graph are Depth-First Search (DFS) and Breadth-First Search (BFS)

Depth-First Search: 
DFS is an algorithm for searching or traversing a graph both directed or undirected.
	As the name suggests it searches as deeper as possible in the graph. 
IDEA: 
	Visits all the nodes that are not visited from recently visited node and if all the vertices that are reachable from the vertex are seen then it recurses back. Here, when we reach a node it is marked as seen, and is marked as visited when all the nodes that are reachable from the node are seen.
	Here we maintain  the information about whether the node is seen or not because the graph may contain cycles. If the cycle is present in a graph then we may visit the node twice and keep on moving in the loop if we don't maintain the information whether the node is visited or not.
Let us see an example to see the working of the algorithm. 
Example: 
	Consider a directed graph G shown below 
	      Here initially all the nodes are marked as not visited.Now lets start the algorithm from node 1. 
Now, we mark the node 1 as seen and move to the next node that can be reached (node 2).
 
Now, we mark the node 2 as seen and move to the next node that can be reached from 2 and as there are two nodes 3 and 5 we choose the left node.

Now as there are no nodes that can be reached from 5 we mark the node 5 as visited and recurse back to 2. And we move to node 3 that can be reached from 2.

Now as all the nodes that are reachable from 3 are seen we mark node 3 as visited and recurse back to node 2.
 
As all the nodes that can be reached from node 2 are seen we recurse back to node 1. 

As all the nodes that are reachable from node 1 are seen we mark 1 as visited. And as we cannot recurse back from 1 we check whether all nodes in the graph are visited and select the node that is not visited. So, now we select the node 4.

Now, we mark 4 as seen and move to node 6 (node that is reachable from 4).

Now as there are no nodes that can be reached from 6 we mark 6 as visited and recurse back to 4.

As all the nodes that are reachable from 4 are seen we mark 4 as visited. As there are no nodes to recurse back and all the nodes of the graph are seen the final output of the traversal is 
	1,2,5,3,4,6.
There can be multiple traversals and the Algorithm gives one the traversal. The other traversals for the above graph can be (4,1,2,5,3,6); (6,4,1,2,5,3); … 
 
Algorithm: 
We maintain an array to know the status of the node (not-visited, seen or visited). Then mark every vertex of the graph as not-visited.
And every non visited vertex in the graph is passed as an argument to the function DFS_Traversal()
In the function DFS_Traversal() we mark the non-visited node as seen and then we move to the vertices that can be reached from the node. And do the same.
After performing this on all the vertices that can be reached we mark the root vertex as visited.

Pseudo Code:
DFS(Graph G,int V)
{
   // status[i] = 0 => not visited, 1 => seen, 2 => visited
   int status[V+1] = {0}; // V = no.of Vertices
   for every vertex v ∈ V  // V = set of vertices of G
       if(status[v] == 0)
           DFS_Traversal(G, v, status);
   return;
}
DFS_Traversal(Graph G, int v, int* status)
{
   status[v] = 1;
   for every u ∈ Adj[v] // => there is a vertex from v to u
       if(status[u] == 0)
           DFS_Traversal(G,u,status);
   status[v] = 2;
   return;
}

Code Implementation:
 	# check vscode.
Analysis
Time Complexity:
	According to the algorithm DFS_Traversal() is called for each vertex exactly once and in the function we check all the edges from the vertex. So, we are checking all the edges of the graph. 
	Thus, Time complexity of the Algorithm is O(V+E) where V = number of vertices of the graph and E = number of the edges of the graph
Space Complexity: 
As we are maintaining an additional array of size V+1 to store the information about whether the node is visited or not. The Space Complexity of the algorithm is O(V).
Applications:
Helps to find Strongly connected components in a graph.
Detect a cycle in a graph 
To check if the graph is bipartite
Find a path between two given vertices.

Breadth-First Search: 
	BFS is also an algorithm to search in or traverse a graph. As the name suggests it visits all the nodes that are present at the same level first and then advances to the next level.This continues till all the nodes of the graph or visited or stops when we find the required node.
	This can be used in both directed and undirected graphs.
Algorithm: 
We maintain a status array to find out whether the node is not-visited, seen or visited. And we also maintain a queue
Now we choose a node (start node) and then push it’s neighbours on to the queue and then pop an element from the queue and push it’s neighbours on to the queue and so on.. 
We do this till all the nodes are reached from the point and then we choose another node from the graph that is not visited and repeat the same process till all the nodes in the graph are visited. 
The status of the node that is not visited is set as 0 and the status of the node that is in the queue is set as 1 and the node that is popped from the queue is set as 2.
The order of popping the elements is the required BFS traversal.
Let us see an example to see the working of the algorithm.
Example: 
Consider an undirected graph G shown below

Initially the status array is initialized to 0. Now we start with 1 and push it on to the queue and update its status.

Now we pop 1 from the queue and push its neighbours 2 3 5 onto the queue and update the status of nodes 1, 2, 3 and 5 to 2, 1, 1 and 1 respectively.

Now we pop 2 from the queue and push its neighbours onto the queue and update their status.

As there are no neighbours for 3 we just pop 3 from the queue and update the status.
 
Now we pop 5 from the queue and push 6 onto the queue and update their status. 

As there are no neighbours for 4 we just pop 4 from the queue and update the status.

As there are no neighbours for 6 we just pop 6 from the queue and update the status.

Now, All the nodes of the graph are visited.The BFS traversal is 1 2 3 5 4 6.
Pseudo Code:
BFS(Graph G, int V)
{
   vector<int> status(V+1, 0);     // status array
   queue<int> que;         // queue
   for every vertex s ∈ V  // V = set of vertices of G
       if(status[s] == 0)
           que.push(s);
           status[s] = 1;
           BFS_Traversal(G, status, que);
   return;
}
BFS_Traversal(Graph G, vector<int> &status, queue<int> &que)
{
   while queue is not empty
       int v = que.front();
       que.pop();
       // pushing the neighbours of v into queue
       for every u ∈ Adj[v]      // => there is a vertex from v to u
           if(status[u] == 0)
               que.push(u);
               status[u] = 1;      // u is seen
       status[v] = 2;          // v is visited 
   return;
}
Code Implementation:
	// vscode
Analysis:
Time Complexity: 
	Each vertex of the graph is pushed and popped from the queue exactly once.The operations pushing and popping from the queue are constant time operations.So, the time taken to do this is O(V). 
	For each vertex we are checking all the neighbours. So, in total we are checking all the edges in the graph and the time taken to do this is O(E). 
	Thus, Overall time taken by the algorithm is O(V+E) where V = no.of vertices and E = no.of edges of the graph.
Space Complexity: 
	As we are maintaining an array and queue which in the worst case may contain V-1 elements. The space complexity of BFS is O(V).
Applications: 
Cycle detection in undirected graphs
To test if a graph is bipartite
Find path between two vertices 
GPS navigation systems to find all neighbouring places.
Shortest path in undirected graph.
Sorting a graph:
Topological Sort: 
Topological sort is to linearly order vertices of a graph in such a way that if there is an edge from u to v then u comes before v in the ordering. And this sorting is only possible if a graph is directed acyclic graph (DAG). 
Algorithm:
We start with a node and recurse for all its adjacent vertices and mark a node as visited if all its adjacent vertices are visited. 
Similar to DFS and BFS we maintain an array to know whether the vertex is visited or not.
We also maintain a stack and push a node that is visited onto the stack. 
We continue this till all the vertices of the graph are pushed onto the stack. Then we pop the elements of the stack and print them to get the sorted order of vertices of the graph.
Let us see an example to see the working of the algorithm.
Example: 
Consider the DAG G shown below.

Now let's start from node 1 as its adjacent nodes 2, 3 and 4 are not visited. And move to one of them. Let say node 2

Now we check the adjacent vertices of 2 and as they are not visited we move node 4 (adjacent vertex of 2).

Now we check the adjacent vertices of 4 and as they are not visited we move node 5 (adjacent vertex of 4). As there are no adjacent nodes for node 5 we mark 5 as visited and push it onto the stack.

Now we recurse back to node 4 and as all the adjacent nodes of node 4 are visited we mark 4 as visited and push it onto the stack.

Again we recurse back to node 2 and as all its adjacent nodes are visited we push it onto the stack and mark it as visited.

Then we recurse back to node 1 and as node 3 that is adjacent to node 1 is not visited we move to node 3.

As all the adjacent vertices of node 3 are visited we mark it as visited and push it onto stack and recurse back to node 1.

Now as all its adjacent nodes are visited we push 1 onto the stack.

There is no node to recurse back and as all the vertices are pushed onto the stack we pop out the stack to get the order. Here the order is 1 3 2 4 5
Pseudo Code:
Topological_Sort(Graph G,int v,vector<bool>& status,stack<int>& stck)
{
   for every u ∈ Adj[v]        // for every adjacent node of v
       if(status[u] == 0)  // if u is not visited
           Topological_Sort(G,u,status,stck);
  
   stck.push(v);     // push onto stack
   status[v] = 1;      // mark v as visited
 
   return;
}
TSort(Graph G, int V)
{
vector<bool> status(V+1, 0);
stack <int> stck;
 
for every vertex v ∈ V
   		if(status[v] == 0)
       		Topological_Sort(G,v,status,stck);
	return;
}

Code Implementation: 
// vscode
Analysis:
Time Complexity: 
	The Algorithm is similar to DFS as we are performing the traversal and pushing the node onto the stack without printing it. And the push and pop operations  are constant time operations.So, the time complexity of the algorithm is the same as time complexity of DFS, that is O(V+E) where V = no.of vertices and E = no.of edges.
Space Complexity: 
	The space complexity of the algorithm is O(V) as we are maintaining a stack whose maximum length is V. 
Applications:
Used for scheduling jobs from the given dependencies among them.
Used to order compilation tasks.

// shortest path 	-- Dijkstra, bellman ford, Flloyd warshal

Finding Shortest Path
	In our daily life, finding the shortest path between two places is important inorder to reach the destination earlier. This problem can be solved using graph algorithms (Bellman-Ford Algorithm, Dijkstra and Floyd-Warshall Algorithm).
	Here Bellman-Ford and Dijkstra are single source shortest path algorithms where Folyd-Warshall is All pair shortest path algorithm.
	In an unweighted graph we can easily find the shortest path using BFS as the length of the path is equal to the number of edges in the path. To find the shortest path in a weighted graph we use the above mentioned algorithms. 

Bellman-Ford Algorithm
	Finds the shortest path from the given starting point(source) to all other points in the graph. 
IDEA: 
	We initially assume that all points are at infinite distance from the source and then we reduce the distances by finding edges that decrease the length of the path until it finds the actual shortest path. 
This Algorithm works for all the graphs and if there are any negative cycles in the graph it detects them. As if there is a negative cycle in the graph then the shortest path is not defined because we can loop multiple times and reduce the path further.
Let us see an example to see the working of the algorithm. 
Example: 
Consider an indirect graph G = (V, E) shown below.

Initially the distance from source to all other nodes is considered to be infinity.
After 1st iteration according to the algorithm we get

And the result after another iteration is also the same. So, the above distance array contains the distances of all the shortest paths from source. 

Algorithm:
Initialize elements of array(distance) of length |V| to infinity and distance[source] to zero.
Then for every edge (u,v) in the graph check if distance[v] is greater than distance[u] + weight of the edge between u and v. If this is true then update the value of distance[v] to distance[u] + weight of the edge between u and v. Repeat this |V|-1 times. 
We can break from the loop if there is no change in the distance array. 
The values in the array are shortest distances from the source to the corresponding point if there is no negative cycle. 
Now, repeat the loop once more, if the distances decrease then there is a negative cycle in the graph. Otherwise the values in the array are the shortest distances from the source. 
We can also get the actual path by maintaining the vertex from which we get the shortest distance along with distance. 
Pseudo Code:
Bellman_Ford(Graph G, int s, int V)
{
   vector<int> distance(V+1, INFINITE);
   distance[s] = 0;
 
   for(int i = 1;i < V; i++)
       for every (u,v,w) ∈ E    // here w is the weight of the edge
           if(distance[v] > distance[u]+w && distance[u] != INFINITE)
               distance[v] = distance[u] + w;
  
   for every (u,v,w) ∈ E
       if(distance[v] > distance[u] + w && distance[u] != INFINITE)
       {  
           cout << "Negative cycle detected" << endl;
           return;
       }
   for(int i = 1;i <= V+1; i++)
       cout << distance[i] << " ";
   cout << endl;
   return;
}
 
Code Implementation:
// check vscode.
Analysis:
Time Complexity: 
As In the worst case we check all the edges |V| times the time complexity of the algorithm is O(V*E) where V = no.of vertices and E = no.of edges of the graph.
The best case time complexity of the algorithm is O(E) here we get all the shortest paths in one iteration. 
Space Complexity: 
As we need to maintain an array of length V, the space complexity of the algorithm is O(V).
